Az eddigi pédákban szereplõ mûveletek (operation és option együtt)

TABLE ACCESS FULL
             HASH
             CLUSTER
             BY INDEX ROWID
             BY GLOBAL INDEX ROWID
             BY LOCAL INDEX ROWID

PARTITION RANGE ITERATOR   -- több partíció olvasása
PARTITION RANGE ALL        -- összes partíció olvasása
INLIST ITERATOR            -- mûveletek ismétlése

SORT AGGREGATE             -- ha csak egy sor lesz a csoportosítás végén
     UNIQUE                -- ismétlõdések megszüntetéséhez
     GROUP BY              -- ha több csoport lesz
     JOIN                  -- elõrendezés a join-hoz
     ORDER BY

HASH UNIQUE
HASH GROUP BY

UNION-ALL
MINUS
CONCATENATION              -- unió képzése két sorhalmazból
VIEW
FILTER                     -- egy sorhalmaz szûrése

NESTED LOOPS               -- join mûvelet
MERGE JOIN                 -- rendezett részek összefuttatása
HASH JOIN
HASH JOIN ANTI             -- not exist-hez lehet jó
HASH JOIN SEMI             -- ha a join után csak az egyik tábla adatai kellenek

INDEX FAST FULL SCAN       -- IOT tábla teljes olvasása
INDEX RANGE SCAN           -- intervallum keresés
INDEX UNIQUE SCAN          -- egyedi érték keresés

AND-EQUAL                  -- sorazonosító halmazok metszetét képezi

BITMAP INDEX SINGLE VALUE
BITMAP AND                     -- bitmapek közötti logikai mûvelet
BITMAP CONVERSION TO ROWIDS    -- bitmap átalakítása sorazonosítóvá
BITMAP CONVERSION FROM ROWIDS  -- sorazonosító átalakítása bitmappé



Tippek (hint) adasa az optimalizalonak

Mindig csak arra az utasitas blokkra vonatkoznak, amiben szerepelnek. 
Az utasitas blokk a következõk egyike lehet:
- Egyszerû SELECT, UPDATE, DELETE INSERT utasitas
- Komplex utasitasban a subquery, vagy a kulsõ utasitas (pl. INSERT ... SELECT ...)
- Összetett utasitas egyik resze (pl. SELECT ... UNION SELECT ... esetén)
A tipp csak közvetlenul az utasitas kulcsszava utan jöhet megjegyzesben.
[SELECT|DELETE|UPDATE|INSERT]   /*+  tipp lista  */    (a '+' elõtt nincs szoköz !!! )
Ha hiba van a hint-ben az oracle figyelmen kivul hagyja de nem jelez hibat.

Példák:
SELECT /*+ tipp lista */  * FROM emp WHERE ...
SELECT /*+ tipp lista */  * FROM emp WHERE deptno IN ( SELECT /*+ tipp lista */  deptno FROM ...)
INSERT /*+ tipp lista */  ... SELECT /*+ tipp lista */  ...
SELECT /*+ tipp lista */  ...  UNION  SELECT /*+ tipp lista */  ...

Fontos! Ha minõsített tábla szerepel a lekérdezésben akkor használjunk aliast, pl.
  SELECT /*+ full(c) */ ... FROM nikovits.cikk c ...



A legfontosabb tippek:

ALL_ROWS
Költseg alapú optimalizalast valaszt es azon belul is a teljes lekerdezesre optimalizal.

FIRST_ROWS(n)  
A legjobb valaszidõre optimalizál. Az lekérdezés elsõ n sorát a lehetõ leggyorsabban
próbálja meg visszaadni. Ha nem adjuk meg n-et, akkor n=1-et tekinti.

FULL(tabla)   vagy  FULL(aliasnev)
Nem hasznal indexet, hanem full table scant.

CLUSTER(tabla)
Csak clusteren lévõ tábláknál van értelme. 

HASH(tabla)
Csak hash clusteren lévõ táblánál van értelme.


INDEX(tabla  [indexlista])
A tablat index alapjan eri el. Ha nem adunk meg index nevet (vagy többet adunk meg) 
akkor a legolcsóbb költségû indexet (a felsoroltakbol) használja.

INDEX_ASC(tabla  [indexlista])
Növekvõ sorrendben eri el az index bejegyzeseket.

INDEX_DESC(tabla  [indexlista])
Megfordítja az alapértelmezett index bejárási sorrendet. Csökkenõ sorrendben éri el 
az index bejegyzéseket. (Illetve csökkenõ indexnél növekvõben.)

INDEX_COMBINE(tabla  [indexlista])
Bitmap indexek segítségével próbálja meg elérni az adatokat.

INDEX_FFS(tabla  [indexlista])
Fast full index scan-re utasítja az optimalizálót a teljes tábla olvasás helyett.

INDEX_JOIN(tabla  [indexlista])
Több index használatával és a sorazonosítók join-olásával érje el a táblát.

AND_EQUAL(tabla  [indexlista])
Több index egyidejû használatával éri el a táblát. A sorazonosítók metszetét képezi.

NO_INDEX(tabla  [indexlista])
A megadott indexek használatáról lebeszéli az optimalizálót.

NO_INDEX_FFS(tabla  [indexlista])
A megadott indexek használatáról lebeszéli az optimalizálót.

NO_EXPAND
Ha a lekérdezésben OR vagy IN szerepel, akkor az optimalizáló hajlamos az egyes
esetek szerint külön-külön keresni (pl. index használatával). Ez a hint errõl 
beszéli le az optimalizálót.

USE_CONCAT
Az OR feltételekbõl uniót hoz létre, és így hajtja végre a lekérdezést.


LEADING(táblalista)
A megadott táblákkal kezdi a lekérdezés végrehajtását. (Hasonló az ORDERED-hez)

ORDERED
A táblákat abban a sorrendben fogja join-olni, ahogy azok a FROM után megjelennek.

USE_HASH(táblalista)
A megadott tablakat hash join-nal join-olja a többi adatforrashoz. 
NO_USE_HASH(táblalista)
Az elõzõ ellentéte.

USE_NL(táblalista)
A megadott tablakat nested looppal join-olja a többi adatforrashoz. A megadott tabla 
lesz a belsõ ciklus tablaja.
NO_USE_NL(táblalista)
Az elõzõ ellentéte

USE_MERGE(táblalista)
A megadott tablakat sort-merge-el join-olja a többi adatforrashoz.
NO_USE_MERGE(tablalista) 
Az elõzõ ellentéte.

CURSOR_SHARING_EXACT
Arra utasítja az oracle-t, hogy semmiképpen ne cserélje le az utasítás elemzése 
közben a literálokat bind változóra. Amúgy ezt lehet, hogy megtenné mivel ezzel
csökkenne az újraelemzések esélye. (lásd -> CURSOR_SHARING init paraméter)

DRIVING_SITE(tabla)
Elosztott lekérdezésnél van értelme. Arra utasítja az optimalizálót, hogy a megadott 
tábla adatbázisában hajtsa végre a mûveletet. (pl. join esetén távoli táblák között)

DYNAMIC_SAMPLING(tabla n) ahol 0 <= n <= 10
Menet közben próbál meg minta alapján döntéseket hozni a szelektivitásra vonatkozóan.
Minél nagyobb az n értéke, annál nagyobb mintát használ.

CACHE(tabla)
Hatasara a tabla blokkjai a buffer cache LRU listajanak "friss" vegere kerulnek. 
Kis tablaknal hasznos, hogy sokaig csücsülhessenek a bufferben.

NOCACHE(tabla)
Hatasara a tabla blokkjai a buffer cache LRU listajanak "régi" vegere kerulnek. 
Alapertelmezes szerint is ide kerulnenek.

APPEND
INSERT utasításban az utolsó blokk utáni területre teszi be az adatokat, és nem a blokkokban
meglévõ szabad helyekre. Ezáltal gyorsabb lesz, de pazarlóbb.

NOAPPEND
A blokkok meglévõ üres helyeit is kihasználja. (Illetve letiltja a párhuzamos insert-et)

MERGE(V)
V egy nézet neve. A nézet kiértékelésének egyik módja a nézet merge-elése a 
fõ lekérdezésbe. Erre utasítja az optimalizálót. Inline nézet esetén a hintet
beírhatjuk a nézet blokkjába (paraméter nélkül), vagy a fõ lekérdezésbe (paraméterrel).

NO_MERGE(V)
Az elõzõ ellentétére veszi rá az optimalizálót.

NO_QUERY_TRANSFORMATION
Az optimalizáló képes arra, hogy a lekérdezést valamilyen módon átalakítsa, és azt
hajtsa végre. Ilyen átalakítás például az OR-expansion, View-merging, Subquery-unnest,
Star-transformation, Materialized view-rewrite. A hint ezekrõl beszéli le az optimalizálót.
A fenti átalakítások mindegyike külön-külön is kérhetõ illetve letiltható egy hinttel.
USE_CONCAT - NO_EXPAND, MERGE - NO_MERGE, UNNEST - NO_UNNEST, 
STAR_TRANSFORMATION - NO_STAR_TRANSFORMATION, REWRITE - NO_REWRITE

RULE
Szabály alapú optimalizálást használ, de ez a hint már nem javasolt.


